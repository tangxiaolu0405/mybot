# 知识图谱记忆存储系统

## 设计原则

### 核心理念
- **图结构优先**：用节点和关系表达知识的内在联系
- **语义化存储**：每个节点都有明确的类型和属性
- **动态演化**：知识图谱随使用不断生长和优化
- **高效检索**：支持基于关系的快速查询和推理

### Linus哲学应用
- **消除特殊情况**：所有记忆都是节点，通过关系连接
- **实用主义**：用Markdown实现，无需引入复杂图数据库
- **简洁执念**：用最少的语法表达最丰富的语义

## 图结构定义

### 节点类型

#### 1. 实体节点 (Entity)
表示具体的概念、对象或实例

```yaml
节点ID: entity_001
类型: 实体
名称: CLAW项目
属性:
  创建时间: 2026-02-26
  状态: 开发中
  优先级: 高
标签: [项目, AI, 自主系统]
```

#### 2. 事件节点 (Event)
表示发生的事情或操作

```yaml
节点ID: event_001
类型: 事件
名称: 创建memory-reader技能
时间: 2026-02-26 01:00:00
属性:
  执行者: AI
  结果: 成功
  耗时: 5分钟
标签: [技能创建, 记忆管理]
```

#### 3. 概念节点 (Concept)
表示抽象的概念或模式

```yaml
节点ID: concept_001
类型: 概念
名称: AI自主决策
属性:
  定义: AI无需用户干预即可完成任务的决策机制
  适用范围: 技能检查、创建、使用
标签: [AI能力, 自主性]
```

#### 4. 规则节点 (Rule)
表示约束、规则或最佳实践

```yaml
节点ID: rule_001
类型: 规则
名称: 向后兼容性不可破坏
属性:
  优先级: 最高
  来源: Linus哲学
  应用场景: 所有代码修改
标签: [设计原则, 约束]
```

#### 5. 模式节点 (Pattern)
表示可复用的解决方案模式

```yaml
节点ID: pattern_001
类型: 模式
名称: 链表删除优化
属性:
  原始: 10行带if判断
  优化: 4行无条件分支
  效果: 消除边界情况
标签: [代码优化, 好品味]
```

### 关系类型

#### 1. 包含关系 (CONTAINS)
表示整体与部分的关系

```yaml
源节点: entity_001
目标节点: entity_002
关系类型: CONTAINS
属性:
  强度: 强
  时间: 永久
```

#### 2. 依赖关系 (DEPENDS_ON)
表示依赖或前置条件

```yaml
源节点: skill_001
目标节点: skill_002
关系类型: DEPENDS_ON
属性:
  类型: 直接依赖
  必需: true
```

#### 3. 实现关系 (IMPLEMENTS)
表示实现或实例化

```yaml
源节点: entity_001
目标节点: concept_001
关系类型: IMPLEMENTS
属性:
  完成度: 80%
```

#### 4. 触发关系 (TRIGGERS)
表示触发或因果关系

```yaml
源节点: event_001
目标节点: event_002
关系类型: TRIGGERS
属性:
  延迟: 0
  条件: 自动
```

#### 5. 相似关系 (SIMILAR_TO)
表示相似或类比关系

```yaml
源节点: pattern_001
目标节点: pattern_002
关系类型: SIMILAR_TO
属性:
  相似度: 0.85
  维度: [结构, 目标, 方法]
```

#### 6. 冲突关系 (CONFLICTS_WITH)
表示冲突或互斥

```yaml
源节点: rule_001
目标节点: rule_002
关系类型: CONFLICTS_WITH
属性:
  严重性: 高
  解决方案: 优先级排序
```

#### 7. 演化关系 (EVOLVES_TO)
表示演化或升级

```yaml
源节点: pattern_001
目标节点: pattern_003
关系类型: EVOLVES_TO
属性:
  时间: 2026-02-26
  原因: 性能优化
```

## 图谱存储格式

### 主图谱文件 (knowledge_graph.md)

```markdown
# CLAW知识图谱

## 元数据
- 版本: 1.0
- 创建时间: 2026-02-26
- 最后更新: 2026-02-26
- 节点总数: 0
- 关系总数: 0

## 节点索引
- 实体节点: entities.md
- 事件节点: events.md
- 概念节点: concepts.md
- 规则节点: rules.md
- 模式节点: patterns.md

## 关系索引
- 包含关系: contains.md
- 依赖关系: depends.md
- 实现关系: implements.md
- 触发关系: triggers.md
- 相似关系: similar.md
- 冲突关系: conflicts.md
- 演化关系: evolves.md

## 图谱统计
- 节点密度: 0.00
- 平均度数: 0.00
- 最大连通分量: 0
```

### 节点文件示例 (entities.md)

```markdown
# 实体节点

## entity_001: CLAW项目
- 类型: 实体
- 创建时间: 2026-02-26
- 状态: 开发中
- 优先级: 高
- 标签: [项目, AI, 自主系统]

### 出边
- CONTAINS → entity_002 (brain目录)
- CONTAINS → entity_003 (skills目录)
- IMPLEMENTS → concept_001 (AI自主决策)

### 入边
- (无)

### 属性
- 目标: 构建具有学习能力和自适应机制的AI代理系统
- 设计哲学: 好品味、实用主义、简洁执念
- 技术栈: Claude API, Markdown, Git

---

## entity_002: brain目录
- 类型: 实体
- 创建时间: 2026-02-26
- 状态: 已创建
- 优先级: 高

### 出边
- CONTAINS → entity_004 (core.md)
- CONTAINS → entity_005 (memory目录)

### 入边
- CONTAINS ← entity_001 (CLAW项目)

### 属性
- 路径: brain/
- 用途: 存储核心思维模式和记忆系统
```

### 关系文件示例 (contains.md)

```markdown
# 包含关系

## rel_001
- 源节点: entity_001 (CLAW项目)
- 目标节点: entity_002 (brain目录)
- 关系类型: CONTAINS
- 强度: 强
- 时间: 永久

### 双向引用
- entity_001 出边 #1
- entity_002 入边 #1

---

## rel_002
- 源节点: entity_001 (CLAW项目)
- 目标节点: entity_003 (skills目录)
- 关系类型: CONTAINS
- 强度: 强
- 时间: 永久

### 双向引用
- entity_001 出边 #2
- entity_003 入边 #1
```

## 图谱操作

### 节点操作

#### 添加节点
1. 生成唯一节点ID
2. 确定节点类型
3. 填写节点属性
4. 添加到对应节点文件
5. 更新主图谱元数据

#### 查询节点
- 按ID查询: 直接定位
- 按类型查询: 扫描对应节点文件
- 按标签查询: 全图扫描标签
- 按属性查询: 全图扫描属性

#### 更新节点
1. 定位节点
2. 更新属性
3. 检查关系一致性
4. 更新时间戳

#### 删除节点
1. 检查入边关系
2. 处理依赖关系
3. 删除所有相关边
4. 从节点文件移除
5. 更新主图谱元数据

### 关系操作

#### 添加关系
1. 验证源节点和目标节点存在
2. 生成唯一关系ID
3. 确定关系类型
4. 填写关系属性
5. 添加到对应关系文件
6. 更新源节点出边索引
7. 更新目标节点入边索引
8. 更新主图谱元数据

#### 查询关系
- 按ID查询: 直接定位
- 按类型查询: 扫描对应关系文件
- 按源节点查询: 查询节点出边
- 按目标节点查询: 查询节点入边
- 按路径查询: 广度优先/深度优先遍历

#### 更新关系
1. 定位关系
2. 更新属性
3. 更新节点索引
4. 更新时间戳

#### 删除关系
1. 定位关系
2. 从关系文件移除
3. 更新源节点出边索引
4. 更新目标节点入边索引
5. 更新主图谱元数据

## 图谱查询

### 基础查询

#### 1. 节点查询
```python
# 按ID查询
get_node_by_id(node_id)

# 按类型查询
get_nodes_by_type(node_type)

# 按标签查询
get_nodes_by_tag(tag)

# 按属性查询
get_nodes_by_attribute(key, value)
```

#### 2. 关系查询
```python
# 按ID查询
get_relation_by_id(relation_id)

# 按类型查询
get_relations_by_type(relation_type)

# 查询出边
get_outgoing_relations(node_id)

# 查询入边
get_incoming_relations(node_id)
```

### 高级查询

#### 1. 路径查询
```python
# 最短路径
find_shortest_path(source_id, target_id)

# 所有路径
find_all_paths(source_id, target_id, max_depth)

# 路径过滤
find_paths_with_filter(source_id, target_id, filter_func)
```

#### 2. 邻居查询
```python
# 直接邻居
get_neighbors(node_id)

# N跳邻居
get_n_hop_neighbors(node_id, n)

# 邻居类型过滤
get_neighbors_by_type(node_id, neighbor_type)
```

#### 3. 子图查询
```python
# 节点子图
get_subgraph_by_nodes(node_ids)

# 关系子图
get_subgraph_by_relations(relation_ids)

# N跳子图
get_n_hop_subgraph(node_id, n)
```

#### 4. 图谱分析
```python
# 连通分量
find_connected_components()

# 节点中心性
calculate_centrality(node_id)

# 节点度数
get_degree(node_id)

# 图密度
calculate_density()
```

## 图谱演化

### 自动演化机制

#### 1. 访问频率追踪
- 记录每个节点的访问次数
- 记录每个关系的查询次数
- 更新时间戳

#### 2. 重要性评估
- 基于访问频率计算重要性
- 基于关系密度计算重要性
- 基于用户反馈调整重要性

#### 3. 节点合并
- 检测相似节点
- 评估合并可行性
- 执行合并操作
- 更新关系网络

#### 4. 关系优化
- 检测冗余关系
- 评估关系强度
- 优化关系权重

#### 5. 模式识别
- 识别重复子图
- 提取通用模式
- 创建模式节点

### 手动演化操作

#### 1. 批量导入
- 从外部数据导入节点
- 从外部数据导入关系
- 验证数据一致性

#### 2. 批量导出
- 导出节点数据
- 导出关系数据
- 生成图谱快照

#### 3. 图谱合并
- 合并两个知识图谱
- 处理节点冲突
- 处理关系冲突

#### 4. 图谱分割
- 按主题分割
- 按时间分割
- 按类型分割

## 与现有系统集成

### 记忆系统集成

#### 1. 长期记忆
- 将长期记忆转换为实体节点
- 将记忆关联转换为关系
- 保持记忆的时效性和重要性

#### 2. 短期记忆
- 将会话信息转换为事件节点
- 将任务上下文转换为关系
- 支持快速检索和清理

#### 3. 工作记忆
- 将当前任务转换为临时节点
- 将任务依赖转换为关系
- 任务完成后归档或删除

### 技能系统集成

#### 1. 技能节点
- 每个技能作为实体节点
- 技能描述作为属性
- 技能标签作为标签

#### 2. 依赖关系
- 技能依赖作为DEPENDS_ON关系
- 技能组合作为CONTAINS关系

#### 3. 使用关系
- 技能使用作为事件节点
- 技能效果作为属性
- 技能反馈作为关系

## 性能优化

### 存储优化

#### 1. 索引优化
- 节点ID索引
- 节点类型索引
- 节点标签索引
- 关系类型索引

#### 2. 分区策略
- 按节点类型分区
- 按时间分区
- 按主题分区

#### 3. 压缩存储
- 节点属性压缩
- 关系属性压缩
- 历史版本压缩

### 查询优化

#### 1. 缓存机制
- 热点节点缓存
- 常用查询缓存
- 路径查询缓存

#### 2. 查询优化
- 查询计划优化
- 索引利用优化
- 遍历顺序优化

#### 3. 增量更新
- 增量索引更新
- 增量统计更新
- 增量缓存更新

## 扩展性设计

### 节点类型扩展
- 支持自定义节点类型
- 支持节点类型继承
- 支持节点类型转换

### 关系类型扩展
- 支持自定义关系类型
- 支持关系属性扩展
- 支持关系权重计算

### 查询语言扩展
- 支持复杂查询条件
- 支持聚合查询
- 支持图算法查询

## 实施计划

### 阶段1: 基础实现
1. 实现节点存储和查询
2. 实现关系存储和查询
3. 实现基础图操作

### 阶段2: 高级功能
1. 实现路径查询
2. 实现子图查询
3. 实现图谱分析

### 阶段3: 智能演化
1. 实现自动演化机制
2. 实现模式识别
3. 实现节点合并

### 阶段4: 系统集成
1. 集成记忆系统
2. 集成技能系统
3. 性能优化

## 示例场景

### 场景1: 技能推荐
```
用户请求: "我需要处理PDF文件"
1. 查询"PDF"相关节点
2. 查找与"PDF"相关的技能节点
3. 检查技能依赖关系
4. 评估技能适用性
5. 推荐最优技能
```

### 场景2: 问题诊断
```
用户反馈: "这个功能有问题"
1. 创建问题节点
2. 查找相关功能节点
3. 查找相关事件节点
4. 分析关系网络
5. 定位潜在原因
```

### 场景3: 知识推理
```
用户询问: "为什么这个决策是正确的?"
1. 查询决策节点
2. 查找决策依据节点
3. 查找相关规则节点
4. 构建推理路径
5. 生成解释
```

## 总结

知识图谱记忆存储系统通过节点和关系的图结构，实现了知识的语义化存储和智能检索。该系统：

1. **消除特殊情况**：所有记忆都是节点，通过统一的关系连接
2. **实用主义**：基于Markdown实现，无需引入复杂依赖
3. **简洁执念**：用最少的语法表达最丰富的语义
4. **动态演化**：随使用不断生长和优化
5. **高效检索**：支持基于关系的快速查询和推理

该系统与现有的记忆系统和技能系统无缝集成，为AI自主决策提供了强大的知识支撑。
